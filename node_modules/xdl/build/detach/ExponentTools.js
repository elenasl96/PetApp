"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDirectory = isDirectory;
exports.saveUrlToPathAsync = saveUrlToPathAsync;
exports.getManifestAsync = getManifestAsync;
exports.spawnAsyncThrowError = spawnAsyncThrowError;
exports.spawnAsync = spawnAsync;
exports.getResolvedLocalesAsync = getResolvedLocalesAsync;
exports.regexFileAsync = regexFileAsync;
exports.deleteLinesInFileAsync = deleteLinesInFileAsync;

function _spawnAsync() {
  const data = _interopRequireDefault(require("@expo/spawn-async"));

  _spawnAsync = function () {
    return data;
  };

  return data;
}

function _axios() {
  const data = _interopRequireDefault(require("axios"));

  _axios = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _XDLError() {
  const data = _interopRequireDefault(require("../XDLError"));

  _XDLError = function () {
    return data;
  };

  return data;
}

function _Logger() {
  const data = _interopRequireWildcard(require("./Logger"));

  _Logger = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function saveUrlToPathAsync(url, path, timeout = 20000) {
  const response = await _axios().default.get(url, {
    responseType: 'stream',
    timeout
  });
  return new Promise(function (resolve, reject) {
    const stream = _fsExtra().default.createWriteStream(path);

    stream.on('close', resolve);
    stream.on('error', reject);
    response.data.on('error', reject).pipe(stream);
  });
}

async function getManifestAsync(url, headers, options = {}) {
  const buildPhaseLogger = options.logger || _Logger().default.withFields({
    buildPhase: 'reading manifest'
  });

  let response;

  try {
    response = await _retryPromise(() => _axios().default.get(url.replace('exp://', 'http://'), {
      headers
    }));
  } catch (err) {
    buildPhaseLogger.error(err);
    throw new Error('Failed to fetch manifest from www');
  }

  buildPhaseLogger.info('Using manifest:', JSON.stringify(response.data, null, 2));
  return response.data;
}

async function _retryPromise(fn, retries = 5) {
  try {
    return await fn();
  } catch (err) {
    if (retries-- > 0) {
      return await _retryPromise(fn, retries);
    } else {
      throw err;
    }
  }
}

async function spawnAsyncThrowError(command, args, options = {
  stdio: 'inherit',
  cwd: process.cwd()
}) {
  const {
    pipeToLogger
  } = options;

  if (pipeToLogger) {
    options.stdio = 'pipe';
    options.cwd = options.cwd || process.cwd();
  }

  const promise = (0, _spawnAsync().default)(command, args, options);

  if (pipeToLogger && promise.child) {
    const streams = {};

    if (pipeToLogger === true || pipeToLogger.stdout) {
      streams.stdout = promise.child.stdout;
    }

    if (pipeToLogger === true || pipeToLogger.stderr) {
      streams.stderr = promise.child.stderr;
    }

    (0, _Logger().pipeOutputToLogger)(streams, options.loggerFields, options);
  }

  return promise;
}

async function spawnAsync(command, args, options) {
  try {
    return await spawnAsyncThrowError(command, args, options);
  } catch (e) {
    _Logger().default.error(e.message);
  }
}

function isDirectory(dir) {
  try {
    if (_fsExtra().default.statSync(dir).isDirectory()) {
      return true;
    }

    return false;
  } catch (e) {
    return false;
  }
}

async function getResolvedLocalesAsync(projectRoot, exp) {
  const locales = {};

  if (exp.locales !== undefined) {
    for (const [lang, localePath] of Object.entries(exp.locales)) {
      const s = await _fsExtra().default.readFile(_path().default.resolve(projectRoot, localePath), 'utf8');

      try {
        locales[lang] = JSON.parse(s);
      } catch (e) {
        throw new (_XDLError().default)('INVALID_JSON', JSON.stringify(e));
      }
    }
  }

  return locales;
}

async function regexFileAsync(regex, replace, filename) {
  const file = await _fsExtra().default.readFile(filename);
  const fileString = file.toString();
  await _fsExtra().default.writeFile(filename, fileString.replace(regex, replace));
} // Matches sed /d behavior


async function deleteLinesInFileAsync(startRegex, endRegex, filename) {
  const file = await _fsExtra().default.readFile(filename);
  const fileString = file.toString();
  const lines = fileString.split(/\r?\n/);
  const filteredLines = [];
  let inDeleteRange = false;

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(startRegex)) {
      inDeleteRange = true;
    }

    if (!inDeleteRange) {
      filteredLines.push(lines[i]);
    }

    if (inDeleteRange && lines[i].match(endRegex)) {
      inDeleteRange = false;
    }
  }

  await _fsExtra().default.writeFile(filename, filteredLines.join('\n'));
}
//# sourceMappingURL=../__sourcemaps__/detach/ExponentTools.js.map
