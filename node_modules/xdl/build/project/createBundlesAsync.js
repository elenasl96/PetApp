"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printBundleSizes = printBundleSizes;
exports.createBundlesAsync = createBundlesAsync;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _devServer() {
  const data = require("@expo/dev-server");

  _devServer = function () {
    return data;
  };

  return data;
}

function _axios() {
  const data = _interopRequireDefault(require("axios"));

  _axios = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _Logger() {
  const data = _interopRequireDefault(require("../Logger"));

  _Logger = function () {
    return data;
  };

  return data;
}

function UrlUtils() {
  const data = _interopRequireWildcard(require("../UrlUtils"));

  UrlUtils = function () {
    return data;
  };

  return data;
}

function _XDLError() {
  const data = _interopRequireDefault(require("../XDLError"));

  _XDLError = function () {
    return data;
  };

  return data;
}

function TableText() {
  const data = _interopRequireWildcard(require("../logs/TableText"));

  TableText = function () {
    return data;
  };

  return data;
}

function _TerminalLink() {
  const data = require("../logs/TerminalLink");

  _TerminalLink = function () {
    return data;
  };

  return data;
}

function _startLegacyReactNativeServerAsync() {
  const data = require("../start/startLegacyReactNativeServerAsync");

  _startLegacyReactNativeServerAsync = function () {
    return data;
  };

  return data;
}

function _resolveEntryPoint() {
  const data = require("../tools/resolveEntryPoint");

  _resolveEntryPoint = function () {
    return data;
  };

  return data;
}

function ProjectUtils() {
  const data = _interopRequireWildcard(require("./ProjectUtils"));

  ProjectUtils = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MINIMUM_BUNDLE_SIZE = 500;

function printBundleSizes(bundles) {
  const files = [['index.ios.js', bundles.ios.code], ['index.android.js', bundles.android.code]]; // Account for inline source maps

  if (bundles.ios.map) {
    files.push([_chalk().default.dim('index.ios.js.map'), bundles.ios.map]);
  }

  if (bundles.android.map) {
    files.push([_chalk().default.dim('index.android.js.map'), bundles.android.map]);
  }

  _Logger().default.global.info('');

  _Logger().default.global.info(TableText().createFilesTable(files));

  _Logger().default.global.info('');

  _Logger().default.global.info(`ðŸ’¡ JavaScript bundle sizes affect startup time. ${_chalk().default.dim((0, _TerminalLink().learnMore)(`https://expo.fyi/javascript-bundle-sizes`))}`);

  _Logger().default.global.info('');
}

async function createBundlesAsync(projectRoot, publishOptions = {}, bundleOptions) {
  if (!bundleOptions.useDevServer) {
    try {
      await (0, _startLegacyReactNativeServerAsync().startReactNativeServerAsync)({
        projectRoot,
        options: {
          nonPersistent: true,
          maxWorkers: publishOptions.maxWorkers,
          target: publishOptions.target,
          reset: publishOptions.resetCache
        },
        verbose: !publishOptions.quiet
      });
      return await fetchPublishBundlesAsync(projectRoot);
    } finally {
      await (0, _startLegacyReactNativeServerAsync().stopReactNativeServerAsync)(projectRoot);
    }
  }

  const isLegacy = (0, _config().isLegacyImportsEnabled)((0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true
  }).exp); // If not legacy, delete the target option to prevent warnings from being thrown.

  if (!isLegacy) {
    delete publishOptions.target;
  }

  const platforms = ['android', 'ios'];
  const [android, ios] = await (0, _devServer().bundleAsync)(projectRoot, {
    target: publishOptions.target,
    resetCache: publishOptions.resetCache,
    logger: ProjectUtils().getLogger(projectRoot),
    quiet: publishOptions.quiet
  }, platforms.map(platform => ({
    platform,
    entryPoint: (0, _resolveEntryPoint().resolveEntryPoint)(projectRoot, platform),
    dev: bundleOptions.dev
  })));
  return {
    android,
    ios
  };
} // Fetch iOS and Android bundles for publishing


async function fetchPublishBundlesAsync(projectRoot, opts) {
  const entryPoint = (0, _resolveEntryPoint().resolveEntryPoint)(projectRoot);
  const publishUrl = await UrlUtils().constructPublishUrlAsync(projectRoot, entryPoint, undefined, opts);
  const sourceMapUrl = await UrlUtils().constructSourceMapUrlAsync(projectRoot, entryPoint);
  const assetsUrl = await UrlUtils().constructAssetsUrlAsync(projectRoot, entryPoint);

  _Logger().default.global.info('Building iOS bundle');

  const iosBundle = await _getForPlatformAsync(projectRoot, publishUrl, 'ios', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });

  _Logger().default.global.info('Building Android bundle');

  const androidBundle = await _getForPlatformAsync(projectRoot, publishUrl, 'android', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });

  _Logger().default.global.info('Building source maps');

  const iosSourceMap = await _getForPlatformAsync(projectRoot, sourceMapUrl, 'ios', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });
  const androidSourceMap = await _getForPlatformAsync(projectRoot, sourceMapUrl, 'android', {
    errorCode: 'INVALID_BUNDLE',
    minLength: MINIMUM_BUNDLE_SIZE
  });

  _Logger().default.global.info('Building asset maps');

  const iosAssetsJson = await _getForPlatformAsync(projectRoot, assetsUrl, 'ios', {
    errorCode: 'INVALID_ASSETS'
  });
  const androidAssetsJson = await _getForPlatformAsync(projectRoot, assetsUrl, 'android', {
    errorCode: 'INVALID_ASSETS'
  });
  return {
    android: {
      code: androidBundle,
      map: androidSourceMap,
      assets: JSON.parse(androidAssetsJson)
    },
    ios: {
      code: iosBundle,
      map: iosSourceMap,
      assets: JSON.parse(iosAssetsJson)
    }
  };
}

async function _getForPlatformAsync(projectRoot, url, platform, {
  errorCode,
  minLength
}) {
  const fullUrl = `${url}&platform=${platform}`;
  let response;

  try {
    response = await _axios().default.request({
      url: fullUrl,
      responseType: 'text',
      // Workaround for https://github.com/axios/axios/issues/907.
      // Without transformResponse, axios will parse the body as JSON regardless of the responseType/
      transformResponse: [data => data],
      proxy: false,
      validateStatus: status => status === 200,
      headers: {
        'Exponent-Platform': platform
      }
    });
  } catch (error) {
    if (error.response) {
      if (error.response.data) {
        let body;

        try {
          body = JSON.parse(error.response.data);
        } catch (e) {
          ProjectUtils().logError(projectRoot, 'expo', error.response.data);
        }

        if (body) {
          if (body.message) {
            ProjectUtils().logError(projectRoot, 'expo', body.message);
          } else {
            ProjectUtils().logError(projectRoot, 'expo', error.response.data);
          }
        }
      }

      throw new (_XDLError().default)(errorCode, `Packager URL ${fullUrl} returned unexpected code ${error.response.status}. ` + 'Please open your project in the Expo app and see if there are any errors. ' + 'Also scroll up and make sure there were no errors or warnings when opening your project.');
    } else {
      throw error;
    }
  }

  if (!response.data || minLength && response.data.length < minLength) {
    throw new (_XDLError().default)(errorCode, `Body is: ${response.data}`);
  }

  return response.data;
}
//# sourceMappingURL=../__sourcemaps__/project/createBundlesAsync.js.map
