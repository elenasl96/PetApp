"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.publishAsync = publishAsync;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _formData() {
  const data = _interopRequireDefault(require("form-data"));

  _formData = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _Analytics() {
  const data = _interopRequireDefault(require("../Analytics"));

  _Analytics = function () {
    return data;
  };

  return data;
}

function _ApiV() {
  const data = _interopRequireDefault(require("../ApiV2"));

  _ApiV = function () {
    return data;
  };

  return data;
}

function _Config() {
  const data = _interopRequireDefault(require("../Config"));

  _Config = function () {
    return data;
  };

  return data;
}

function EmbeddedAssets() {
  const data = _interopRequireWildcard(require("../EmbeddedAssets"));

  EmbeddedAssets = function () {
    return data;
  };

  return data;
}

function _Env() {
  const data = require("../Env");

  _Env = function () {
    return data;
  };

  return data;
}

function _Logger() {
  const data = _interopRequireDefault(require("../Logger"));

  _Logger = function () {
    return data;
  };

  return data;
}

function _ProjectAssets() {
  const data = require("../ProjectAssets");

  _ProjectAssets = function () {
    return data;
  };

  return data;
}

function Sentry() {
  const data = _interopRequireWildcard(require("../Sentry"));

  Sentry = function () {
    return data;
  };

  return data;
}

function _User() {
  const data = _interopRequireDefault(require("../User"));

  _User = function () {
    return data;
  };

  return data;
}

function _XDLError() {
  const data = _interopRequireDefault(require("../XDLError"));

  _XDLError = function () {
    return data;
  };

  return data;
}

function ExponentTools() {
  const data = _interopRequireWildcard(require("../detach/ExponentTools"));

  ExponentTools = function () {
    return data;
  };

  return data;
}

function Doctor() {
  const data = _interopRequireWildcard(require("./Doctor"));

  Doctor = function () {
    return data;
  };

  return data;
}

function _createBundlesAsync() {
  const data = require("./createBundlesAsync");

  _createBundlesAsync = function () {
    return data;
  };

  return data;
}

function _getPublishExpConfigAsync() {
  const data = require("./getPublishExpConfigAsync");

  _getPublishExpConfigAsync = function () {
    return data;
  };

  return data;
}

function _runHook() {
  const data = require("./runHook");

  _runHook = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function publishAsync(projectRoot, options = {}) {
  var _options$target, _exp$android, _exp$ios, _exp$ios2, _exp$android2, _options$releaseChann;

  options.target = (_options$target = options.target) !== null && _options$target !== void 0 ? _options$target : (0, _config().getDefaultTarget)(projectRoot);
  const target = options.target;
  const user = await _User().default.ensureLoggedInAsync();

  if ((0, _Env().isDebug)()) {
    console.log();
    console.log('Publish Assets:');
    console.log(`- Asset target: ${target}`);
    console.log();
  }

  _Analytics().default.logEvent('Publish', {
    projectRoot,
    developerTool: _Config().default.developerTool
  });

  const validationStatus = await Doctor().validateWithNetworkAsync(projectRoot);

  if (validationStatus === Doctor().ERROR || validationStatus === Doctor().FATAL) {
    throw new (_XDLError().default)('PUBLISH_VALIDATION_ERROR', "Couldn't publish because errors were found. (See logs above.) Please fix the errors and try again.");
  } // Get project config


  const {
    exp,
    pkg,
    hooks
  } = await (0, _getPublishExpConfigAsync().getPublishExpConfigAsync)(projectRoot, options); // Exit early if kernel builds are created with robot users

  if (exp.isKernel && user.kind === 'robot') {
    throw new (_XDLError().default)('ROBOT_ACCOUNT_ERROR', 'Kernel builds are not available for robot users');
  } // TODO: refactor this out to a function, throw error if length doesn't match


  const validPostPublishHooks = (0, _runHook().prepareHooks)(hooks, 'postPublish', projectRoot);
  const bundles = await (0, _createBundlesAsync().createBundlesAsync)(projectRoot, options, {
    useDevServer: (0, _Env().shouldUseDevServer)(exp)
  });
  (0, _createBundlesAsync().printBundleSizes)(bundles);
  await (0, _ProjectAssets().publishAssetsAsync)({
    projectRoot,
    exp,
    bundles
  });
  const androidBundle = bundles.android.code;
  const iosBundle = bundles.ios.code;
  const hasHooks = validPostPublishHooks.length > 0;
  const shouldPublishAndroidMaps = !!((_exp$android = exp.android) === null || _exp$android === void 0 ? void 0 : _exp$android.publishSourceMapPath);
  const shouldPublishIosMaps = !!((_exp$ios = exp.ios) === null || _exp$ios === void 0 ? void 0 : _exp$ios.publishSourceMapPath);
  const androidSourceMap = hasHooks || shouldPublishAndroidMaps ? bundles.android.map : null;
  const iosSourceMap = hasHooks || shouldPublishIosMaps ? bundles.ios.map : null;
  let response;

  try {
    response = await _uploadArtifactsAsync({
      pkg,
      exp,
      iosBundle,
      androidBundle,
      options
    });
  } catch (e) {
    if (e.serverError === 'SCHEMA_VALIDATION_ERROR') {
      throw new Error(`There was an error validating your project schema. Check for any warnings about the contents of your app.json or app.config.js.`);
    }

    Sentry().captureException(e);
    throw e;
  }

  let androidManifest = {};
  let iosManifest = {};

  if (validPostPublishHooks.length || ((_exp$ios2 = exp.ios) === null || _exp$ios2 === void 0 ? void 0 : _exp$ios2.publishManifestPath) || ((_exp$android2 = exp.android) === null || _exp$android2 === void 0 ? void 0 : _exp$android2.publishManifestPath) || EmbeddedAssets().shouldEmbedAssetsForExpoUpdates(projectRoot, exp, pkg, target)) {
    [androidManifest, iosManifest] = await Promise.all([ExponentTools().getManifestAsync(response.url, {
      'Exponent-SDK-Version': exp.sdkVersion,
      'Exponent-Platform': 'android',
      'Expo-Release-Channel': options.releaseChannel,
      Accept: 'application/expo+json,application/json'
    }), ExponentTools().getManifestAsync(response.url, {
      'Exponent-SDK-Version': exp.sdkVersion,
      'Exponent-Platform': 'ios',
      'Expo-Release-Channel': options.releaseChannel,
      Accept: 'application/expo+json,application/json'
    })]);
    const hookOptions = {
      url: response.url,
      exp,
      iosBundle,
      iosSourceMap,
      iosManifest,
      androidBundle,
      androidSourceMap,
      androidManifest,
      projectRoot,
      log: msg => {
        _Logger().default.global.info({
          quiet: true
        }, msg);
      }
    };

    for (const hook of validPostPublishHooks) {
      _Logger().default.global.info(`Running postPublish hook: ${hook.file}`);

      try {
        (0, _runHook().runHook)(hook, hookOptions);
      } catch (e) {
        _Logger().default.global.warn(`Warning: postPublish hook '${hook.file}' failed: ${e.stack}`);
      }
    }
  }

  const fullManifestUrl = response.url.replace('exp://', 'https://');
  await EmbeddedAssets().configureAsync({
    projectRoot,
    pkg,
    exp,
    releaseChannel: (_options$releaseChann = options.releaseChannel) !== null && _options$releaseChann !== void 0 ? _options$releaseChann : 'default',
    iosManifestUrl: fullManifestUrl,
    iosManifest,
    iosBundle,
    iosSourceMap,
    androidManifestUrl: fullManifestUrl,
    androidManifest,
    androidBundle,
    androidSourceMap,
    target
  }); // TODO: move to postPublish hook
  // This method throws early when a robot account is used for a kernel build

  if (exp.isKernel && user.kind !== 'robot') {
    await _handleKernelPublishedAsync({
      user,
      exp,
      projectRoot,
      url: response.url
    });
  }

  return { ...response,
    url: options.releaseChannel && options.releaseChannel !== 'default' ? `${response.url}?release-channel=${options.releaseChannel}` : response.url
  };
}

async function _uploadArtifactsAsync({
  exp,
  iosBundle,
  androidBundle,
  options,
  pkg
}) {
  _Logger().default.global.info('');

  _Logger().default.global.info('Uploading JavaScript bundles');

  const formData = new (_formData().default)();
  formData.append('expJson', JSON.stringify(exp));
  formData.append('packageJson', JSON.stringify(pkg));
  formData.append('iosBundle', iosBundle, 'iosBundle');
  formData.append('androidBundle', androidBundle, 'androidBundle');
  formData.append('options', JSON.stringify(options));
  const user = await _User().default.ensureLoggedInAsync();

  const api = _ApiV().default.clientForUser(user);

  return await api.uploadFormDataAsync('publish/new', formData);
}

async function _handleKernelPublishedAsync({
  projectRoot,
  user,
  exp,
  url
}) {
  var _exp$kernel, _exp$kernel2;

  let kernelBundleUrl = `${_Config().default.api.scheme}://${_Config().default.api.host}`;

  if (_Config().default.api.port) {
    kernelBundleUrl = `${kernelBundleUrl}:${_Config().default.api.port}`;
  }

  kernelBundleUrl = `${kernelBundleUrl}/@${user.username}/${exp.slug}/bundle`;

  if ((_exp$kernel = exp.kernel) === null || _exp$kernel === void 0 ? void 0 : _exp$kernel.androidManifestPath) {
    const manifest = await ExponentTools().getManifestAsync(url, {
      'Exponent-SDK-Version': exp.sdkVersion,
      'Exponent-Platform': 'android',
      Accept: 'application/expo+json,application/json'
    });
    manifest.bundleUrl = kernelBundleUrl;
    manifest.sdkVersion = 'UNVERSIONED';
    await _fsExtra().default.writeFile(_path().default.resolve(projectRoot, exp.kernel.androidManifestPath), JSON.stringify(manifest));
  }

  if ((_exp$kernel2 = exp.kernel) === null || _exp$kernel2 === void 0 ? void 0 : _exp$kernel2.iosManifestPath) {
    const manifest = await ExponentTools().getManifestAsync(url, {
      'Exponent-SDK-Version': exp.sdkVersion,
      'Exponent-Platform': 'ios',
      Accept: 'application/expo+json,application/json'
    });
    manifest.bundleUrl = kernelBundleUrl;
    manifest.sdkVersion = 'UNVERSIONED';
    await _fsExtra().default.writeFile(_path().default.resolve(projectRoot, exp.kernel.iosManifestPath), JSON.stringify(manifest));
  }
}
//# sourceMappingURL=../__sourcemaps__/project/publishAsync.js.map
